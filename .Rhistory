skrrrahh(22)
skrrrahh(23)
skrrrahh(24)
skrrrahh(25)
skrrrahh(26)
skrrrahh(27)
skrrrahh(28)
skrrrahh(29)
skrrrahh(29)
skrrrahh(30)
skrrrahh(31)
skrrrahh(31)
skrrrahh(32)
skrrrahh(33)
skrrrahh(34)
skrrrahh(35)
skrrrahh(36)
skrrrahh(36)
skrrrahh(37)
skrrrahh(37)
skrrrahh(38)
skrrrahh(39)
skrrrahh(40)
skrrrahh(41)
skrrrahh(42)
skrrrahh(42)
skrrrahh(43)
skrrrahh(44)
skrrrahh(44)
skrrrahh(45)
skrrrahh(46)
skrrrahh(46)
skrrrahh(47)
skrrrahh(48)
skrrrahh(49)
skrrrahh(50)
skrrrahh(51)
skrrrahh(52)
skrrrahh(26)
105-54]
105-54
17/51
189400+(325/2)
189454+(326/2)
189617+(326/2)
1/2
4/4
a <- seq(1,10,1)
a
for (i in 1:10){b <- a[i]^2}
b
b <- rep(NA,10)
b
for (i in 1:10){b <- a[i]^2}
b
a
b <- for (i in 1:10){a[i]^2}
b
b <- rep(NA,10)
b
a
b <- for (i in 1:10){a[i]^2}
b
b <- rep(NA,10)
b
for (i in 1:10){b[i] <- a[i]^2}
b
b <- rep(NA,10)
b
for (i in 1:10){b[i] <- a[i]^2/(a[i]+a[i])}
b
.991-/.945
.991-.945
0.046/.945
log(.991/.945)
log(.991/.861)
.991-.945
.861-.908
log(0.046/-0.047)
log(-0.047)
log(0.046/0.047)
.991-.945
log(-0.047)
0.945+(1.96*se)=1.001
1.001-0.945
0.056/1.96
0.945+(1.96*0.285)
0.945+(1.96*0.0285)
96/12
.945+.991
1.936/2
0.908+0.861
1.769/2
ln(0.968/0.8845)
log(0.968/0.8845)
log(.991/.861)
ln(0.991/0.861)
log(0.991/0.861)
1.041-0.991
0.05/1.96
0.991+(1.96*0.0255)
0.0255102*sqrt(10000)
0.0255102*sqrt(8)
96/12
1990-1983
7*12
mean(10,15)
mean(10,15,11,12)
mean(c(10,15))
log((mean(c(17.1,13.6,9.1,7.1,4.6,5.4,3.5)))/mean(c(4.8,6,6.1,6,7.4,10.9,11.9)))
?sd
sd()
sd
var
54/12
2003-1999
4*12
2003-2000
2012-2005
49/100
sqrt(3)
72/12
2004-1999
-0.007/-0.08
-0.08/-0.007
log(-.0875)
log(0.0875)
-0.007/-0.0875
exp(-0.0819)
mean(c(exp(-0.0703),exp(0.1985),exp(0.212),exp(0.104),exp(0.041),exp(-0.003),exp(-0.2344),exp(0.17406),exp(-0.1715),exp(-0.335),exp(0.006),exp(-0.1715)))
exp(-0.0819)
exp(-0.0074)
=AVERAGE(STDEV.S(-0.0563,0.2334,0.0239,0.0937,0.1531,-0.426),STDEV.S(-0.503,-0.3286,0.2124,-0.1471,0.0169,-0.2553))
mean(c(sd(-0.0563,0.2334,0.0239,0.0937,0.1531,-0.426),sd(-0.503,-0.3286,0.2124,-0.1471,0.0169,-0.2553)))
mean(c(sd(c(-0.0563,0.2334,0.0239,0.0937,0.1531,-0.426)),sd(c(-0.503,-0.3286,0.2124,-0.1471,0.0169,-0.2553))))
mean(c(sd(c(exp(-0.0563),exp(0.2334),exp(0.0239),exp(0.0937),exp(0.1531),exp(-0.426))),sd(c(exp(-0.503),exp(-0.3286),exp(0.2124),exp(-0.1471),exp(0.0169),exp(-0.2553)))))
mean(c(0.9,0.8,0.7,0.85))
mean(c(0.7,0.66,0.57,0.9))
mean(c(0.8125,7075))
mean(c(0.8125,.7075))
mean(c(mean(c(0.9,0.7)),mean(c(0.8,0.66)),mean(c(0.7,0.57)),mean(c(0.85,0.9))))
0.914,1,0.965,0.967,0.9507,0.9753,1,0.914,0.89204,0.74242
0.9128,0.8958,0.9829,0.9848,0.926,0.9526,0.9393,0.9545,0.9507,0.8314
0.2808,0.6928,0.1985,0.61048,0.7378,0.7041,0.73033,0.8277,0.7265,0.0861
0.4756,0.3857,0.2696,0.5917,0.4868,0.5917,0.6367,0.5093,0.7191,0.3033
1.1*0.8
10*0.8
10*1.1
11*0.8
1.1*0.8
1.1*0.8
0.88*10
(0.6-2)/0.6
(0.6-2)/2
0.9509,0.73459,1.0702,0.9418
2004-1994
2004-2003
install.packages("astrochron")
library(astrochron)
?astrochron
?cycles
ex <- cycles(start=0,end=500,noisevar=0.0004,dt=5)
ex
?surrogates
ran_ex <- surrogates(ex,nsim=1)
ran_ex
ran_ex <- surrogates(ex,nsim=100)
ran_ex
windows();
plot(ex,type="l",main="black=original; red=surrogate")
lines(ran_ex,col="red",lty=4)
ran_ex <- surrogates(ex,nsim=1)
windows();
plot(ex,type="l",main="black=original; red=surrogate")
lines(ran_ex,col="red",lty=4)
surrogates
install.packages(c("AICcmodavg", "gstat", "interplot", "ncf", "rasterVis", "rgeos", "tidyverse"))
?glmer
?glmm
library(glmm)
library(lme4)
?glmer
library(nlme)
?lme
#
# Fuzzy membership functions
fuzzify<- function(mf, x, rescale=F, min=NULL,mean=NULL,max=NULL){
# find fuzzy membership of x in each fuzzy set mf
# mf is a list of fuzzy set values (membership functions)
# triangular, trapezoid and shelf functions only
# output is x and the membership of x in each fuzzy set in mf
# rescale first rescales mf on the unit interval using rescale.mf()
#
# D. Ramsey 25/4/04
if(rescale) {
mf<- rescale.mf(mf,mean,min,max)
}
n<- length(mf) # we have n fuzzy sets
numx<- length(x)
result<- matrix(NA,nrow=numx,ncol=(n+1))
result[,1]<- x
mu.x<- rep(NA,n) # membership value of x in each set
for(i in 1:numx) {
xi<- x[i]
for(j in 1:n){
# 1st and last elements of mf are shelf functions
if(j==1) {
left<- mf[[j]][1,1]
right<- mf[[j]][2,1]
if(xi >= right) mu.x[j]<- 1
else
if(xi > left & xi < right) mu.x[j]<- 1-(right - xi)/(right-left)
else mu.x[j]<- 0
}
else if(j==n)
{# last is a shelf
left<- mf[[j]][2,1]
right<- mf[[j]][3,1]
if(xi <= left) mu.x[j]<- 1
else
if(xi > left & xi < right) mu.x[j]<- (right - xi)/(right-left)
else mu.x[j]<- 0
}
else if(nrow(mf[[j]])==3)
{# triangular
left<- mf[[j]][1,1]
centre<- mf[[j]][2,1]
right<- mf[[j]][3,1]
if(xi > left & xi <= centre) mu.x[j]<- 1-(centre - xi)/(centre-left)
else
if(xi > centre & xi < right) mu.x[j]<- (right - xi)/(right-centre)
else 	mu.x[j]<- 0
}
else if(nrow(mf[[j]])==4)
{# trapezoid
left<- mf[[j]][1,1]
centre1<- mf[[j]][2,1]
centre2<- mf[[j]][3,1]
right<- mf[[j]][4,1]
if(xi > left & xi < centre1) mu.x[j]<- 1-(centre1 - xi)/(centre1-left)
else
if(xi > centre2 & xi < right) mu.x[j]<- (right - xi)/(right-centre2)
else
if(xi >=centre1 & xi <= centre2) mu.x[j]<- 1
else 	mu.x[j]<- 0
}# end trapezoid
} #j
result[i,c(2:(n+1))]<- mu.x
}#i
return(result)
}
#------------------------------------------------------------
defuzzify<- function(mf,fs, rescale=F,min=NULL,mean=NULL,max=NULL,nint=100){
#
# Defuzzify using "centre of gravity" method (numerical integration of piecewise fuzzy sets)
# fs is output of fuzzify()
# rescale - scale fs to the unit interval and defuzzify
# or else map unit interval back to real scale
# nint = delta x - number of intervals used for integration
tmp<- mf
n<- length(tmp)
if(rescale) {
tmp<- 	rescale.mf(mf,mean,min,max)
dx<- seq(0,1,1/nint)
}
else {
tmp<- mf
dx<- seq(0,max,max/nint)
}
out<- rep(NA,nrow(fs))
for(i in 1:nrow(fs)){
mu.x<- fs[i,2:(n+1)]
sumfx<- rep(NA,length(dx))
sumfx.j<- rep(NA,n)
for(j in 1:length(dx)){
sumfx.j<- rep(0,n)
for(k in 1:n){
# 1st j is  shelf
if(mu.x[k]>0 & k==1) {
left<- tmp[[k]][1,1]
right<- tmp[[k]][2,1]
if(dx[j] >= right) sumfx.j[k]<- 1
else
if(dx[j] > left & dx[j] < right) sumfx.j[k]<- 1-(right - dx[j])/(right-left)
else sumfx.j[k]<- 0
sumfx.j[k]<- min(sumfx.j[k],mu.x[k])
}
else if(mu.x[k]>0 & k==n)
{
# last j is a shelf
left<- tmp[[k]][2,1]
right<- tmp[[k]][3,1]
if(dx[j] <= left) sumfx.j[k]<- 1
else
if(dx[j] > left & dx[j] < right) sumfx.j[k]<- (right - dx[j])/(right-left)
else sumfx.j[k]<- 0
sumfx.j[k]<- min(sumfx.j[k],mu.x[k])
}
else if(mu.x[k]>0){
if(nrow(tmp[[k]])==3){# triangular
left<- tmp[[k]][1,1]
centre<- tmp[[k]][2,1]
right<- tmp[[k]][3,1]
if(dx[j] > left & dx[j] <= centre) sumfx.j[k]<- 1-(centre - dx[j])/(centre-left)
else
if(dx[j] > centre & dx[j] < right) sumfx.j[k]<- (right - dx[j])/(right-centre)
else 	sumfx.j[k]<- 0
sumfx.j[k]<- min(sumfx.j[k],mu.x[k])
}#end triangular
else if(nrow(tmp[[k]])==4)
{# trapezoid
left<- tmp[[k]][1,1]
centre1<- tmp[[k]][2,1]
centre2<- tmp[[k]][3,1]
right<- tmp[[k]][4,1]
if(dx[j] > left & dx[j] < centre1) sumfx.j[k]<- 1-(centre1 - dx[j])/(centre1-left)
else
if(dx[j] > centre2 & dx[j] < right) sumfx.j[k]<- (right - dx[j])/(right-centre2)
else
if(dx[j] >=centre1 & dx[j] <= centre2) sumfx.j[k]<- 1
else 	sumfx.j[k]<- 0
}# end trapezoid
sumfx.j[k]<- min(sumfx.j[k],mu.x[k])
}
} # k loop
sumfx[j]<- max(sumfx.j)
} #j loop
out[i]<- sum(sumfx*dx)/sum(sumfx)
} # i loop
return(cbind(fs,out))
}
#========================================================
# rescaling function
rescale.mf<- function(mf,mean,min,max){
#
# rescale the membership function mf on the unit interval
# using 2 piecewise linear transformations
# so that the mean value = 0.5
n<- length(mf)
for(i in 1:n){
k<- nrow(mf[[i]])
for(j in 1:k){
if(mf[[i]][j,1]<=mean) mf[[i]][j,1]<- (1-((mean - mf[[i]][j,1])/(mean-min)))*0.5
else
mf[[i]][j,1]<- 0.5 + ((1 -((max-mf[[i]][j,1])/(max-mean)))*0.5)
}
}
return(mf)
}
#----------------------
# rescale to unit interval
rescale<- function(dat){
min.dat<- min(dat)
max.dat<- max(dat)
newdat<- (dat-min.dat)/(max.dat-min.dat)
newdat
}
fcm<- function(s,w,fix=rep(0,length(s)),
lambda=0.5, max.iter=500,
af=rep(1,length(s)), tol=0.001,c=5) {
#
# Fuzzy cognitive map algorithm
# s is the initial state vector variable [0,1]
# w is the matrix of edge weights [-1,1]
# fix is the vector indicating which element of s are fixed boundary conditions
# lambda is the relaxation parameter to speed convergence
# activation functions are (1)logistic, (2) threshold exponential or (3) threshold linear
# af - vector specifying which activation function to be used on each element of s
#
# D. Ramsey 30/4/04
#
state<- matrix(nrow=max.iter,ncol=length(s))
raw<- matrix(nrow=max.iter,ncol=length(s))
state[1,]<- s
raw[1,]<- s
iter<- 1
for(z in 2:max.iter) {
tmp<- w %*% state[z-1,]
for(i in 1:nrow(w)) {
if(af[i]==1){
# logistic
state[z,i] <- lambda* (1/(1+exp(-c*tmp[i]))) + (1-lambda)*state[z-1,i]
raw[z,i]<- tmp[i]
}
else if(af[i]==2) {
# exponential
state[z,i]<- lambda * max(0,1-exp(-c*tmp[i])) + (1-lambda)*state[z-1,i]
raw[z,i]<- tmp[i]
}
else if(af[i]==3){
# linear
state[z,i] <- lambda* (min(1,max(0,c*tmp[i]))) + (1-lambda)*state[z-1,i]
raw[z,i]<- tmp[i]
}
}
state[z,fix==1]<- state[1,fix==1] # reset boundary conditions (control)
ind<- abs(state[z,] - state[z-1,]) < tol
if(length(state[z,ind])==length(s)) break
iter<- iter + 1
}
if(iter == max.iter) cat(" WARNING ! Convergence not reached in ",max.iter," iterations",'\n')
else cat("convergence reached after ",iter," iterations",'\n')
list(state=state[1:iter,],raw=raw[1:iter,],iter=iter)
}
# Crossbill abundance
high<- matrix(cbind(c(0.5,0.8,1),c(0,1,1)),ncol=2)
mod<- matrix(cbind(c(0.2,0.5,0.8),c(0,1,0)),ncol=2)
low<- matrix(cbind(c(0,0.2,0.5),c(1,1,0)),ncol=2)
crossbill.mf<- list(high=high,mod=mod,low=low)
# Test membership functions with graph
mf<- crossbill.mf
max<- mf[[1]][3,1]
mean<- mf[[2]][2,1]
min<- 0
tmp<- rescale.mf(mf,mean,min,max)
n<- length(mf)
windows();
par(mfrow=c(1,2))
plot(c(0,max),c(0,1),type='n',tck=0.02,las=1,xlab=)
for(i in 1:n){
lines(mf[[i]][,1],mf[[i]][,2])
}
title("Fuzzy membership functions (original scale)")
plot(c(0,1),c(0,1),type='n',tck=0.02,las=1)
for(i in 1:n){
lines(tmp[[i]][,1],tmp[[i]][,2])
}
title("Fuzzy membership functions (rescaled)")
# affect of column on row
w <- matrix(0,nrow=4,ncol=4)
species <- c("spruce","crossbill","squirrel","marten")
dimnames(w) <- list(species,species)
w["spruce","spruce"] <- 0.5
w["crossbill","spruce"] <- 0.25
w["squirrel","spruce"] <- 0.9
w["marten","spruce"] <- 0
w["spruce","crossbill"] <- -0.25
w["crossbill","crossbill"] <- -0.25
w["squirrel","crossbill"] <- 0
w["marten","crossbill"] <- 0
w["spruce","squirrel"] <-  -0.9
w["crossbill","squirrel"] <- 0
w["squirrel","squirrel"] <- 0
w["marten","squirrel"] <- 0.25
w["spruce","marten"] <- 0
w["crossbill","marten"] <- 0
w["squirrel","marten"] <- -0.25
w["marten","marten"] <- -0.25
# run null model
s<- c(0.5,0.5,0.5,0.5) # regular set-up
fix<- c(0,0,0,0)
af<- c(1,2,2,2)
test<- fcm(s,w,tol=0.001,lambda=0.5,c=1,fix=fix,af=af) #change c to 1
# Crossbill abundance
high<- matrix(cbind(c(0.5,0.8,1),c(0,1,1)),ncol=2)
mod<- matrix(cbind(c(0.2,0.5,0.8),c(0,1,0)),ncol=2)
low<- matrix(cbind(c(0,0.2,0.5),c(1,1,0)),ncol=2)
crossbill.mf<- list(high=high,mod=mod,low=low)
# FCM runs for each "boundary condition"
# iterate number of squirrels and watch crossbill abundance
squirrel <- seq(0,1,0.1)
# other variable of interest
result <- data.frame(squirrel)
result[,2] <- rep(NA,nrow(result)) # crossbill column
# what happens when we introduce more squirrels?
for(m in 1:nrow(result)){
s<- c(0.5,0.5,result[m,1],0.5)
fix<- c(0,0,1,0)
af<- c(1,2,2,2)
test<- fcm(s,w,tol=0.001,lambda=0.5,c=5,fix=fix,af=af)
result[m,1] <- test$state[test$iter,3]
result[m,2] <- test$state[test$iter,2]
}
# results = end state of each converged sample...no fuzziness yet
names(result) <- c("squirrel","crossbill") # great results!
result
# Lets make the crossbills fuzzy!
# Fuzzify and defuzzify
crossbill.f<- fuzzify(crossbill.mf,result$crossbill,rescale=T,
min=0,max=1,mean=0.5)
crossbill.f
crossbill.df<- defuzzify(crossbill.mf,crossbill.f,rescale=T,
min=0,max=1,mean=0.5)
crossbill.df
exp(.5)
blogdown:::serve_site()
setwd("~/GitHub")
blogdown:::serve_site()
blogdown::serve_site()
setwd("~/GitHub/My_Website")
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::install_hugo()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::install_hugo()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
library(blogdown)
blogdown::serve_site()
